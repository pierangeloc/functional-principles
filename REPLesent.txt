| \gTypeclasses

| Pierangelo Cecchetto
| @pierangelocecc
| @TulipLogic


| \y\*\!TulipLogic B.V.

---
| \*Example 1: Sorting

--

\*List of Int

```
def sort(l: List[Int]): List[Int] = l match {
  case Nil => Nil
  case x :: xs =>
    val (lessThan, notLessThan) = xs.partition(_ < x)
    sort(lessThan) ++ List(x) ++ sort(notLessThan)
}

```

---
| \* Example 1: Sorting

\*List of String

```
def sort(l: List[String]): List[String] = l match {
   case Nil => Nil
   case x :: xs =>
     val (lessThan, notLessThan) = xs.partition(_ < x)
     sort(lessThan) ++ List(x) ++ sort(notLessThan)
 }
```
--

\*Drawback: I can do too much with a fixed type, and I have to
\*implement one sort for every type
--

```
def sort2(l: List[String]): List[String] = l match {
   case Nil => Nil
   case x :: xs =>
     val (lessThan, notLessThan) = xs.partition(_ < x)
     sort(lessThan) ++ List(x) ++ sort(notLessThan).map(_.toUpperCase)
 }
```

---
| \* Example 1: Sorting

\*General solution

```
def sort[A](l: List[A]): List[A] = l match {
    case Nil => Nil
    case x :: xs =>
      val (lessThan, notLessThan) = xs.partition(_ < x)
      sort(lessThan) ++ List(x) ++ sort(notLessThan)
  }
```
--

| \*We took away the structure through polymorphism
--

| \*Great!!! :muscle:
--

| \*It doesn't compile! :disappointed:

---
| \* Example 1: Sorting

\*General solution


\*- We must bring back the minimal requirements to sort

--

```
def sort[A](l: List[A])(lt: (A, A) => Boolean): List[A] = l match {
    case Nil => Nil
    case x :: xs =>
      val (lessThan, notLessThan) = xs.partition(lt(_, x) == true)
      sort(lessThan)(lt) ++ List(x) ++ sort(notLessThan)(lt)
  }
```

--



\*- We are still in trouble: \_lt\s \*has no restrictions
---

---
| \* :star: Typeclasses need laws :star::star::star:

\*Laws for \_lt

- Must satisfy Order relationship laws:
   forall a: A, b: A, c: A if a < b && b < c ==> a < c
   forall a: A, b: A, c: A if lt(a, b) && lt(b, c) ==> lt(a, c)

--

```
def ltLaws[A](lt: (A, A) => Boolean)(implicit arbA: Arbitrary[A]) =
  new Properties("lt") {
    property("transitivity") = forAll {
        (a: A, b: A, c: A) =>
          (lt(a, b) == true && lt(b, c) == true )  ==>
             lt(a, c) == true
      }
    }
```